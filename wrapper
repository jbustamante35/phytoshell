#!/bin/bash
#################################################################################
# This is the wrapper script that serves as the ENTRYPOINT for the phytoshell
# Docker image. It parses through command line arguments to determine the
# codebase and application to run, and which programming language with which
# to run the application.
#
# In this version, I compiled each of our functions into a single file. I'm
# hoping this helps with simplicity in debugging everything.
#
# Usage:
#       docker run -it phytoshell [verbosity] [codebase] [language_version_application] [additional arguments]
#
# Input:
#       verbosity: output for iRODS command to download codebase (0-none, 1-strong)
#       codebase: CyVerse path to directory containing code and libraries for the application
#                 [our codebase is /iplant/home/nmiller/phytoMorph_public_deploy]
#       language_version_application: argument must be in this format (delimiter _)
#          NOTE: These arguments are to be set from the Discovery Environment using the pull-down menu options.
#                Developers must set these when they build their applications.
#                       language -> m:matlab, mi:matlab gui, r:R, p:python, p2:python2, p3:python3, o:octave, j:julia, b:debug_mode
#                       version -> o:original codebase (ours), a:alternate codebase (user-defined)
#                       application -> name of application to run
#       additional arguments: any command line arguments to pass into the application
#
# Important note about the application parameter:
#       Regardless of the language and application used, the main program must
#       be called DEwrapper followed by the language-specific extension name.
#       (i.e. DEwrapper.py, DEwrapper.jl, etc). This main program can have a
#       switch statement that handles the additional arguments that call a
#       specific application.
#
#       For example, running the MATLAB application maizeSeeling from our
#       default codebase is done using the following command:
#               docker run -it phytoshell 0 na m_o_DEwrapper maizeSeedling
#
# Examples:
# Run the MATLAB application 'methodName' using the default codebase with no verbosity
#   NOTE: The 'na' parameter means do not download an alternate codebase
#       docker run -it phytoshell 0 na m_o_methodName
#
# Run Python application analyzerData with a user's codebase located at
#   /iplant/home/exampleuser/examplecodebase_deploy in verbose mode
#       docker run -it phytoshell 1 /iplant/home/exampleuser/examplecodebase_deploy p_a_analyzeData
#
# Pipeline Overview:
#       1) Check input arguments for language, codebase, and application
#       2) Set codebase directory and configure language environment
#       3) Re-configure argument order and Run command
#
# Authors
#       Nathan Miller, Senior Scientist (ndmill@gmail.com)
#       Julian Bustamante, Graduate Researcher (jbustamante@wisc.edu)
###############################################################################

workingdir=$(pwd)
printf "**************************************************************\n"
printf "*         Phytomorph Docker Image Shell Version 0.5          *\n"
printf "*                  Designed 09/25/2018                       *\n"
printf "*         Authors: Nathan Miller, Julian Bustamante          *\n"
printf "*           Working Directory: ${workingdir}                  *\n"
printf "**************************************************************\n"

######################### Helper Functions ####################################
evalTicket () {
    # Usage: evalTicket [ticket] [target] [command]
    # ticket: iRODS hex code verification
    # target: directory for extracting/exporting data
    # command: 'iget' to extract data (iget) 'iput' to export data (iput)

    # Parse iRODS input file to get ticket and data
    var=$2
    var=$(echo ${var:0:1})
    type=$1

    case $var in
    '#')
            ;;
    *)
        case $type in
        iput)
            ticket=$(echo $2 | cut -f 1 -d ,)
            target=$(echo $2 | cut -f 2 -d ,)
            username=$(echo $target | cut -f 4 -d /)
            sourcedir=$PWD/loadingdock/userdata
            sourcefldr=dataout
            printf "\n\nUSER: ${username}\n\n"
            printf "Using ticket ${ticket} to ${type} ${source} into ${target}\n"
            #iput -v -t $ticket -r $source $target

            # Upload output structure to CyVerse
            # 1) Create master output directory into user's CyVerse directory
            # 2) List master directory structure then call xargs to recursively iput each
            #       file/folder into user's master directory
            # 3) Grant user permissions to master directory
            # 4) Revoke anonymous user's permissions to directory
            iput -Vrt $ticket $sourcedir/$sourcefldr $target

            # Replace spaces in path names to '\ ' with sed
            ls "$sourcedir/$sourcefldr" | sed 's| |\\ |g' | xargs -t -I % \
                iput -Vr $sourcedir/$sourcefldr/% "$target/$sourcefldr"

            ichmod -r own $username "$target/$sourcefldr"
            #hostname=$(jq '.irods_user_name' $target)
            #hostname=anonymous
            hostname=job
            ichmod -r null $hostname "$target/$sourcefldr"
            ;;

        iget)
            ticket=$(echo $2 | cut -f 1 -d ,)
            source=$(echo $2 | cut -f 2 -d ,)
            target=$PWD/loadingdock/userdata/datain/
            printf "Using ticket ${ticket} to ${type} ${source} into ${target}\n"
            iget -v -t "$ticket" -r "$source $target"
            ;;

        *)
            ;;
        esac
    esac

}

ticketParser () {
    fin=$1
    icmd=$2

    # Determine if extracting or exporting data
    case $icmd in
    iget)

        source=$PWD/loadingdock/userdata/datain/
        ;;

    iput)
        source=$PWD/loadingdock/userdata/dataout/
        ;;

    *)
        echo "error with icommand, ..."
        source=$PWD/loadingdock/userdata/dataout/
        ;;

    esac

    # Parse through ticket list to either extract or export data
    while IFS='' read -r line || [[ -n "$line" ]]; do
           evalTicket $icmd $line
    done < "$fin"

}

parseConfig () {
    # Parse through config.json file to extract arguments
    # Arguments are extracted in the following order:
    #   arguments: [
    #        "verbosity",
    #        "user_codebase",
    #        "lang_codebase_application",
    #        "input_data"
    #    ]

    # Concatenate new lines --> extract between '[' and ']' --> remove '"'
    fin=$1
    str=$(echo $fin | tr "\n" " " | cut -f 2 -d [ | cut -f 1 -d ] | tr -d "\"" )

    echo $str

}

configOSG () {
    # Init input file of arguments
    printf "\n**************************************************************\n"
    printf "*                                                            *\n"
    printf "* Downloading user data from iRODS                           *\n"
    printf "*                                                            *\n"
    printf "**************************************************************\n"
    # Get user data from iRODS by parsing through tickets,directories file
    # If
    tickets=$PWD/loadingdock/input_ticket.list
    ticketParser $tickets

    printf "**************************************************************\n"
    printf "*                                                            *\n"
    printf "* Successfully downloaded  user data                         *\n"
    printf "*                                                            *\n"
    printf "**************************************************************\n\n"

    mkdir -p ~/.irods
    mv $PWD/loadingdock/config.json ~/.irods/irods_environment.json
    args=$(parseConfig "$(< ~/.irods/irods_environment.json)")
    echo "[ $args ]"

}

runOSG () {
    echo "No arguments selected. Parsing arguments from config.json"

    # Debug statements
    #echo $PWD
    #find / -name config.json

    # Manually move files we need to our working directory
    cp $workingdir/config.json        $workingdir/loadingdock
    cp $workingdir/output_ticket.list $workingdir/loadingdock
    cp $workingdir/input_ticket.list  $workingdir/loadingdock

    str=$(configOSG)
    output=$( echo $str | cut -f 2 -d [ | cut -f 1 -d ] )
    args=(${output//,/ })

    runner ${args[@]}
    # Return data to user's iRODS server
    ticketParser $workingdir/loadingdock/output_ticket.list iput
}

runCyverse () {
    # Create iRODS directory running commandline arguments [for CyVerse]
    mkdir -p ~/.irods
    mv /loadingdock/irods_environment.json ~/.irods/
    runner $@
}

########################### Main Function #####################################
# Determine if arguments should be run from commandline [run from CyVerse]
# or downloaded from config.json [run from OSG]

# Create directory structure for /loadingdock
mkdir -p \
    $workingdir/loadingdock/userdata/datain  \
    $workingdir/loadingdock/userdata/dataout \
    $workingdir/loadingdock/codebase/o       \
    $workingdir/loadingdock/codebase/a

if [[ $# -eq 0 ]]; then
    echo "Running from OSG"
    runOSG
else
    echo "Running from CyVerse"
    runCyverse
fi

